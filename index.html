<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>3D 同步時鐘預覽</title>
    <style>
        body { margin: 0; background-color: #222; overflow: hidden; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; color: white; font-family: sans-serif; pointer-events: none; }
    </style>
</head>
<body>
    <div id="info">正在同步系統時間...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 場景設定 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        // --- 1. 調整初始相機位置 ---
// 假設你的時鐘正面朝向 Z 軸，將相機放在 Z 軸的正前方
camera.position.set(0, 0, 5); 

// --- 2. 控制器設定 ---
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableDamping = true;

// 限制左右 45 度
controls.minAzimuthAngle = -Math.PI / 4; 
controls.maxAzimuthAngle = Math.PI / 4;

// 限制上下 45 度 (以 90度 為中心)
controls.minPolarAngle = Math.PI / 4;      // 45 度
controls.maxPolarAngle = Math.PI * 3 / 4;  // 135 度 (即 90+45)

// --- 3. 在 animate 函式裡記得更新 ---
function animate() {
    requestAnimationFrame(animate);
    
    // ... 時間同步邏輯 ...

    controls.update(); // 必須呼叫才能讓限制與阻尼生效
    renderer.render(scene, camera);
}

        // 控制器（讓你家用滑鼠旋轉查看時鐘）
        const controls = new OrbitControls(camera, renderer.domElement);

        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- 載入你的 2026-01-05.glb 模型 ---
        let hourHand, minuteHand, secondHand;

        const loader = new GLTFLoader();
        // 請確保檔案名稱與模型檔案一致
        loader.load('2026-01-05.glb', (gltf) => {
            const model = gltf.scene;
            scene.add(model);

            // 抓取模型中的指針節點
            hourHand = model.getObjectByName('HourHand');
            minuteHand = model.getObjectByName('MinuteHand');
            secondHand = model.getObjectByName('SecondHand');

            console.log("時鐘模型載入完畢！");
        }, undefined, (error) => {
            console.error("載入出錯：", error);
        });

        // --- 動畫與時間同步邏輯 ---
     function animate() {
    requestAnimationFrame(animate);

    if (hourHand && minuteHand && secondHand) {
        const now = new Date();
        const s = now.getSeconds();
        const m = now.getMinutes();
        const h = now.getHours();
        const ms = now.getMilliseconds();

        // 1. 計算旋轉比例
        const s_ratio = (s + ms / 1000) / 60;
        const m_ratio = (m + s_ratio) / 60;
        const h_ratio = ((h % 12) + m_ratio) / 12;

        // 2. 轉換為弧度 (2π = 一圈)
        const s_rot = s_ratio * Math.PI * 2;
        const m_rot = m_ratio * Math.PI * 2;
        const h_rot = h_ratio * Math.PI * 2;

        // 3. 根據你的模型結構，應該旋轉 X 軸
        // 如果發現轉的方向反了，把 "-" 號拿掉或加上去
        secondHand.rotation.x = -s_rot;
        minuteHand.rotation.x = -m_rot;
        hourHand.rotation.x = -h_rot;
    }

    controls.update();
    renderer.render(scene, camera);
}

        animate();

        // 視窗縮放處理
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // --- 限制攝影機旋轉範圍 ---
// 1. 禁用平移（右鍵拖拽），讓視角永遠對準中心
controls.enablePan = false;

// 2. 限制左右旋轉 (Azimuth Angle)
// 45 度換算成弧度約為 Math.PI / 4
controls.minAzimuthAngle = -Math.PI / 4; // 左邊 45 度
controls.maxAzimuthAngle = Math.PI / 4;  // 右邊 45 度

// 3. 限制上下旋轉 (Polar Angle)
// 預設正中央是 Math.PI / 2 (90度)
// 我們設定在 90度 加減 45度 之間
controls.minPolarAngle = Math.PI / 2 - Math.PI / 4; // 往上仰 45 度
controls.maxPolarAngle = Math.PI / 2 + Math.PI / 4; // 往下俯 45 度

// 4. (選配) 限制縮放距離，防止拉太遠或太近
controls.minDistance = 2; 
controls.maxDistance = 10;

// 讓旋轉更有手感（增加阻尼感）
controls.enableDamping = true;
controls.dampingFactor = 0.05;
    </script>
</body>

</html>

